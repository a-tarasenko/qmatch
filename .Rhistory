if (is.positive) {
current.position <- positive[next.positive]
next.positive <- next.positive + 1
}
else {
current.position <- negative[next.negative]
next.negative <- next.negative + 1
}
if ((next.positive >= N) | (next.negative >= N)) {
return(switches)
}
}
switches
}
M <- 1000000
result <- rep(0, M)
for (i in 1:M) {
print(paste("Doing", i))
result[i] <- simulate.it()
}
p <- 0.5
N <- 100
simulate.it <- function()
{
positive <- cumsum(rgeom(N, p) + 1)
negative <- (-cumsum(rgeom(N, p) + 1))
next.positive <- 1
next.negative <- 1
current.position <- 0
is.positive <- NA
next.is.positive <- NA
switches <- -1
while (TRUE) {
pos.dist <- positive[next.positive] - current.position
neg.dist <- current.position - negative[next.negative]
next.is.positive <- (pos.dist < neg.dist) | ((pos.dist == neg.dist) & (runif(1) >= 0.5))
if (!identical(is.positive, next.is.positive)) {
switches <- switches + 1
is.positive <- next.is.positive
}
if (is.positive) {
current.position <- positive[next.positive]
next.positive <- next.positive + 1
}
else {
current.position <- negative[next.negative]
next.negative <- next.negative + 1
}
if ((next.positive >= N) | (next.negative >= N)) {
return(switches)
}
}
switches
}
M <- 1000000
result <- rep(0, M)
for (i in 1:M) {
if (i mod 10000 == 0) {
print(paste("Doing", i))
}
result[i] <- simulate.it()
}
p <- 0.5
N <- 100
simulate.it <- function()
{
positive <- cumsum(rgeom(N, p) + 1)
negative <- (-cumsum(rgeom(N, p) + 1))
next.positive <- 1
next.negative <- 1
current.position <- 0
is.positive <- NA
next.is.positive <- NA
switches <- -1
while (TRUE) {
pos.dist <- positive[next.positive] - current.position
neg.dist <- current.position - negative[next.negative]
next.is.positive <- (pos.dist < neg.dist) | ((pos.dist == neg.dist) & (runif(1) >= 0.5))
if (!identical(is.positive, next.is.positive)) {
switches <- switches + 1
is.positive <- next.is.positive
}
if (is.positive) {
current.position <- positive[next.positive]
next.positive <- next.positive + 1
}
else {
current.position <- negative[next.negative]
next.negative <- next.negative + 1
}
if ((next.positive >= N) | (next.negative >= N)) {
return(switches)
}
}
switches
}
M <- 1000000
result <- rep(0, M)
for (i in 1:M) {
if (i mod 10000 == 0) {
print(paste("Doing", i))
}
result[i] <- simulate.it()
}
p <- 0.5
N <- 100
simulate.it <- function()
{
positive <- cumsum(rgeom(N, p) + 1)
negative <- (-cumsum(rgeom(N, p) + 1))
next.positive <- 1
next.negative <- 1
current.position <- 0
is.positive <- NA
next.is.positive <- NA
switches <- -1
while (TRUE) {
pos.dist <- positive[next.positive] - current.position
neg.dist <- current.position - negative[next.negative]
next.is.positive <- (pos.dist < neg.dist) | ((pos.dist == neg.dist) & (runif(1) >= 0.5))
if (!identical(is.positive, next.is.positive)) {
switches <- switches + 1
is.positive <- next.is.positive
}
if (is.positive) {
current.position <- positive[next.positive]
next.positive <- next.positive + 1
}
else {
current.position <- negative[next.negative]
next.negative <- next.negative + 1
}
if ((next.positive >= N) | (next.negative >= N)) {
return(switches)
}
}
switches
}
M <- 1000000
result <- rep(0, M)
for (i in 1:M) {
result[i] <- simulate.it()
}
p <- 0.5
N <- 100
simulate.it <- function()
{
positive <- cumsum(rgeom(N, p) + 1)
negative <- (-cumsum(rgeom(N, p) + 1))
next.positive <- 1
next.negative <- 1
current.position <- 0
is.positive <- NA
next.is.positive <- NA
switches <- -1
while (TRUE) {
pos.dist <- positive[next.positive] - current.position
neg.dist <- current.position - negative[next.negative]
next.is.positive <- (pos.dist < neg.dist) | ((pos.dist == neg.dist) & (runif(1) >= 0.5))
if (!identical(is.positive, next.is.positive)) {
switches <- switches + 1
is.positive <- next.is.positive
}
if (is.positive) {
current.position <- positive[next.positive]
next.positive <- next.positive + 1
}
else {
current.position <- negative[next.negative]
next.negative <- next.negative + 1
}
if ((next.positive >= N) | (next.negative >= N)) {
return(switches)
}
}
switches
}
M <- 1000000
result <- rep(0, M)
for (i in 1:M) {
if (i %% 10000 == 0) {
print(paste("Doing", i))
}
result[i] <- simulate.it()
}
result
unique(result)
mean(result)
sd(result)
sd(result)**2
mean(result)
pr0 <- length(result[result == 0]) / length(result)
pr1 <- length(result[result == 1]) / length(result)
pr2 <- length(result[result == 2]) / length(result)
pr3 <- length(result[result == 3]) / length(result)
p0 <- length(result[result == 0]) / length(result)pr0
pr0
pr0 <- length(result[result == 0]) / length(result)
pr1 <- length(result[result == 1]) / length(result)
pr2 <- length(result[result == 2]) / length(result)
pr3 <- length(result[result == 3]) / length(result)
pr0
p0
p1
p2
p3
pr0
pr1
pr2
pr3
length(result[result == 3])
pr0/pr1
pr1/pr2
pr2/pr3
?read.table
xor(T,F)
xor = 7
xor(T,F)
xor
if (c(T,F,F,T)){print("dsf")}
ifelse(c(T,F,F,T), T, F)
knitr::opts_chunk$set(echo = TRUE)
library(prettyR)
library(MatchIt)
library(cobalt)
library(optmatch)
source("qmatch.R")
load(file = "37106-0001-Data.rda")
df.age = da37106.0001
used.vars <- c("AGE", "SEX", "EDU3", "EMP3", "INCTOTALHOUSEHOLD_LOOP",
"SR_WEIGHT_KILOGRAMMES", "SR_HEIGHT_CENTIMETRES")
rows.amount.before.cleaning = nrow(df.age)
for (var in used.vars) {
df.age = df.age[!is.na(df.age[[var]]),]
}
print(paste0("Data rows after cleaning: ", nrow(df.age),
", dropped rows: ", rows.amount.before.cleaning - nrow(df.age)))
rm(rows.amount.before.cleaning)
# Income
income.levels = levels(df.age$INCTOTALHOUSEHOLD_LOOP)
df.age[["INCOME_NUM"]] = sapply(df.age$INCTOTALHOUSEHOLD_LOOP, function(x){
index = match(x, income.levels)
if (index == 1) {
return(5000)
}
else if (index == 11) {
return(105000)
}
return(index * 10000 - 5000) # Average income increases linearly with each level, these magic values provide it
})
rm(income.levels)
# Weight
weight.levels = levels(df.age$SR_WEIGHT_KILOGRAMMES)
df.age[["WEIGHT_NUM"]] = sapply(df.age$SR_WEIGHT_KILOGRAMMES, function(x){
index = match(x, weight.levels)
if (index == 1) {
return(45)
}
else if (index == 9) {
return(125)
}
return(index * 10 + 35) # Average weight increases linearly with each level, these magic values provide it
})
rm(weight.levels)
# Height
height.levels = levels(df.age$SR_HEIGHT_CENTIMETRES)
df.age[["HEIGHT_NUM"]] = sapply(df.age$SR_HEIGHT_CENTIMETRES, function(x){
index = match(x, height.levels)
if (index == 1) {
return(145)
}
else if (index == 6) {
return(195)
}
return(index * 10 + 135) # Average height increases linearly with each level, these magic values provide it
})
rm(height.levels)
# Income
income.levels = levels(df.age$INCTOTALHOUSEHOLD_LOOP)
df.age[["INCOME_NUM"]] = sapply(df.age$INCTOTALHOUSEHOLD_LOOP, function(x){
index = match(x, income.levels)
if (index == 1) {
return(5000)
}
else if (index == 11) {
return(105000)
}
return(index * 10000 - 5000) # Average income increases linearly with each level, these magic values provide it
})
rm(income.levels)
# Weight
weight.levels = levels(df.age$SR_WEIGHT_KILOGRAMMES)
df.age[["WEIGHT_NUM"]] = sapply(df.age$SR_WEIGHT_KILOGRAMMES, function(x){
index = match(x, weight.levels)
if (index == 1) {
return(45)
}
else if (index == 9) {
return(125)
}
return(index * 10 + 35) # Average weight increases linearly with each level, these magic values provide it
})
rm(weight.levels)
# Height
height.levels = levels(df.age$SR_HEIGHT_CENTIMETRES)
df.age[["HEIGHT_NUM"]] = sapply(df.age$SR_HEIGHT_CENTIMETRES, function(x){
index = match(x, height.levels)
if (index == 1) {
return(145)
}
else if (index == 6) {
return(195)
}
return(index * 10 + 135) # Average height increases linearly with each level, these magic values provide it
})
rm(height.levels)
# BMI is `kg / m^2`
df.age[["BMI"]] = df.age[["WEIGHT_NUM"]] / (df.age[["HEIGHT_NUM"]] ** 2)
# Since we use centimetres for height - add correction multiplier: `10000`
df.age[["BMI"]] = df.age[["BMI"]] * 10000
# `TRUE` for `2366` record and `FALSE` for `2746` records (employed + other), good for 1-to-1 matching
df.age["IS_RETIRED"] = (df.age$EMP3 == "(2) Retired")
# `TRUE` for `1673` record and `FALSE` for `3439` records (retired + other), good for 1-to-2 matching
df.age["IS_EMPLOYED"] = (df.age$EMP3 == "(1) Employed")
fit.formula = (IS_RETIRED ~ AGE + SEX + EDU3 + INCOME_NUM + WEIGHT_NUM + HEIGHT_NUM + BMI)
set.seed(666)
fit = glm(fit.formula, data = df.age, family = binomial)
for (i in 1:100) {
print(paste0("TRYING", i))
test = fullmatch(fit$fitted.values, z = as.numeric(df.age$IS_RETIRED), data = df.age, min.controls = 1, max.controls = 1, omit.fraction = 1.0 - 0.01 * i)
if (!all(test)) {
print(paste0("FOR", i))
break;
}
}
test
test = fullmatch(fit$fitted.values, z = as.numeric(df.age$IS_RETIRED), data = df.age)
test
is.na(test)
all(is.na(test))
for (i in 1:100) {
print(paste0("TRYING", i))
test = fullmatch(fit$fitted.values, z = as.numeric(df.age$IS_RETIRED), data = df.age, min.controls = 1, max.controls = 1, omit.fraction = 1.0 - 0.01 * i)
if (!all(is.na(test))) {
print(paste0("FOR", i))
break;
}
}
summary(test)
for (i in 1:100) {
print(paste0("TRYING", i))
dist = match_on(fit$fitted.values, z = as.numeric(df.age$IS_RETIRED), caliper = 0.1)
test = fullmatch(dist, z = as.numeric(df.age$IS_RETIRED), data = df.age, min.controls = 1, max.controls = 1, omit.fraction = 1.0 - 0.01 * i)
if (!all(is.na(test))) {
print(paste0("FOR", i))
break;
}
}
for (i in 1:400) {
print(paste0("TRYING", i))
dist = match_on(fit$fitted.values, z = as.numeric(df.age$IS_RETIRED), caliper = 0.1)
test = fullmatch(dist, z = as.numeric(df.age$IS_RETIRED), data = df.age, min.controls = 1, max.controls = 1, omit.fraction = 1.0 - 0.0025 * i)
if (!all(is.na(test))) {
print(paste0("FOR", i))
break;
}
}
test
matchfailed(test)
dist
class(dist)
dist = match_on(fit$fitted.values, z = as.numeric(df.age$IS_RETIRED))
dist
dist = match_on(fit$fitted.values, z = as.numeric(df.age$IS_RETIRED), caliper = 0.1)
dist
?match_on
dist = match_on(fit$fitted.values, z = as.numeric(df.age$IS_RETIRED), caliper = 0.1, method = "euclidean")
dist
fit$fitted.values
length(fit$fitted.values)
length(as.numeric(df.age$IS_RETIRED))
names(fit$fitted.values)
names(c(1,2,3))
fit$fitted.values
as.numeric(df.age$IS_RETIRED)
names(as.numeric(df.age$IS_RETIRED))
my.z = as.numeric(df.age$IS_RETIRED)
names(my.z) = names(fit$fitted.values)
my.z = as.numeric(df.age$IS_RETIRED)
names(my.z) = names(fit$fitted.values)
dist = match_on(fit$fitted.values, z = my.z, caliper = 0.1, method = "euclidean")
dist
names(dist)
my.z
my.z
length(as.numeric(df.age$IS_RETIRED))
my.z = as.numeric(df.age$IS_RETIRED)
names(my.z) = names(fit$fitted.values)
dist = match_on(fit$fitted.values, z = my.z, caliper = 0.1, method = "euclidean")
dist
min(dist)
max(dist)
length(dist)
for (i in 1:5000) {
print(paste0("TRYING", i))
test = fullmatch(dist, z = as.numeric(df.age$IS_RETIRED), data = df.age, min.controls = 1, max.controls = 1, omit.fraction = 1.0 - 0.0002 * i)
if (!all(is.na(test))) {
print(paste0("FOR", i))
break;
}
}
source('C:/Users/dkanu/Downloads/ICPSR_37106-V22/ICPSR_37106/main.R', echo=TRUE)
library(prettyR)
library(MatchIt)
# Make variables
load(file = "DS0001/37106-0001-Data.rda")
df = da37106.0001
df = df[!is.na(df$DISVISION),]
df$BLINDVAR = (  df$DISVISION == "(4) Fair"
| df$DISVISION == "(5) Poor or Registered Blind"
| df$DISVISION == "(3) Good")
df$EMPNEW = (  df$EMP3 == "(1) Employed")
df$test = runif(nrow(df))
used.vars <- c("SEX", "EDU3", "PSSSCORE", "DISIMPAIRMENTS", "SOCCLOSETIES", "SOCRELFRIENDS",
"SR_WEIGHT_KILOGRAMMES", "SR_HEIGHT_CENTIMETRES", "INCASSASSETS", "INCASSNETASSETS",
"INCTOTALHOUSEHOLD_LOOP", "EMP3", "MDMEDS_EXCL_SUPPS")
for (var in used.vars) {
df = df[!is.na(df[[var]]),]
}
# Propensity score matching (greedy)
# !!!set random seed
m.out0 <- matchit(EMPNEW ~ AGE + SEX + test, data = df,
method = "nearest", distance = "glm", caliper = 0.1)
summary(m.out0)
library(cobalt)
# Propensity score matching (ours)
source("qmatch.R") # Employment ~ age + sex + income_household + weight + height + bmi + education
fit <- glm(EMPNEW ~ AGE + SEX + test, data = df)
m.out1 <- qmatch(fit, caliper = 0.001, method = "nno") # old value = 831
m.out1
m.out1 <- qmatch(fit, caliper = 0.1, method = "nno") # old value = 831
m.out1
# Propensity score matching (greedy)
# !!!set random seed
m.out0 <- matchit(EMPNEW ~ AGE + SEX + test, data = df,
method = "nearest", distance = "glm", caliper = 0.1)
summary(m.out0)
fit <- glm(EMPNEW ~ AGE + SEX + test, data = df)
m.out1 <- qmatch(fit, caliper = 0.1, method = "nno") # old value = 831
m.out1
# Propensity score matching (greedy)
# !!!set random seed
m.out0 <- matchit(EMPNEW ~ AGE + SEX + test, data = df,
method = "nearest", distance = "glm", caliper = 0.1)
summary(m.out0)
# Propensity score matching (ours)
source("qmatch.R") # Employment ~ age + sex + income_household + weight + height + bmi + education
fit <- glm(EMPNEW ~ AGE + SEX + test, data = df)
m.out1 <- qmatch(fit, caliper = 0.1, method = "nno") # old value = 831
m.out1
fit <- glm(EMPNEW ~ AGE + SEX + test, data = df)
m.out1 <- qmatch(fit, caliper = 0.1, method = "qmatch") # old value = 831
m.out1
install_github("a.tarasenko/qmatch")
install_github("a-tarasenko/qmatch")
library(devtools)
install_github("a-tarasenko/qmatch")
library(devtools)
install_github("a-tarasenko/qmatch")
qmatch
qmatch
library(qmatch)
qmatch
x = c(1,2,3,4,5)
x = c(0.1,0.2,0.3,0.4,0.5)
z = (1,1,0,0,1)
z = c(1,1,0,0,1)
qmatch(z~x, caliper = 0.5)
?qmatch
qmatch.formula
qmatch.formula
ip = as.data.frame(installed.packages()[,c(1,3:4)])
ip
ip = as.data.frame(installed.packages()[,])
ip = as.data.frame(installed.packages())
qmatch
ip
ip[["qmatch"]]
names(ip)
ip["qmatch",]
qmatch
github_install("a-tarasenko/qmatch")
library(devtools)
github_install("a-tarasenko/qmatch")
install_github("a-tarasenko/qmatch")
qmtach
qmatch
library("qmatch")
qmatch
x <- c(0.1,0.2,0.3,0.4,0.5)
z<-c(1,1,0,0,1)
qmatch(x = x, z = z, caliper = 0.5)
qmatch(z ~ x, caliper = 0.5)
setwd("~/Programming projects/qmatch")
devtools::document()
devtools::install_github("a-tarasenko/qmatch")
library(qmatch)
?qmatch
x = c(0.1,0.2,0.3,0.4,0.5)
z = c(1,1,0,0,1)
qmatch(z ~ x, caliper = 0.5)
qmatch(z ~ x, caliper = 0.5, method = "qmatch")
